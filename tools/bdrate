#!/usr/bin/env python3

###
### Copyright (C) 2020 Intel Corporation
###
### SPDX-License-Identifier: BSD-3-Clause
###

import argparse
import ast
import json
import os
import sys
import xml.etree.cElementTree as et

from bd_metric.bjontegaard_metric import * # HINT: sudo pip3 install bd-metric
from datetime import datetime as dt
from slash.utils.pattern_matching import Matcher

def parseArgs():
  parser = argparse.ArgumentParser()

  parser.add_argument(
    'results',
    metavar = '<xmlfile>',
    type = str,
    nargs = 2,
    help = "An xml test result file.  The first file is the reference.",
  )

  parser.add_argument(
    '-a', '--aggregates',
    dest = "aggvars",
    type = str,
    default = "bitrate,qp",
    metavar = "VAR[,VAR]",
    help = "The list of test param names that are aggregated together [default: %(default)s]",
  )

  parser.add_argument(
    '--afilter',
    dest = "afilters",
    type = Matcher,
    action = "append",
    default = [],
    metavar = "FILTER",
  )

  parser.add_argument(
    '--bfilter',
    dest = "bfilters",
    type = Matcher,
    action = "append",
    default = [],
    metavar = "FILTER",
  )

  parser.add_argument(
    '--ref',
    type = str,
    default = "bdrate-ref.json",
  )

  parser.add_argument(
    '--rebase',
    action = "store_true",
    default = False,
  )

  parser.add_argument(
    '--show-points',
    action = "store_true",
    help = "Show the (bitrate, psnr) data points used to compute the bdrate",
  )

  return parser.parse_args()

class Refs:
  def __init__(self, filename, rebase = False):
    self.filename = filename
    self.references = dict()
    self.rebase = rebase

    if os.path.exists(self.filename):
      with open(self.filename, "r") as fd:
        self.references = json.load(fd)

  def check(self, compare, addr, key, value):
    reference = self.references.setdefault(addr, dict())
    if self.rebase:
      reference[key] = value
    ref = reference.get(key, None)
    return compare(ref, value)

  def finalize(self):
    if self.rebase:
      with open(self.filename, "w+") as fd:
        json.dump(self.references, fd, indent = 2, sort_keys = True)

def aggregate(root, filters):
  global aggvars

  result = dict()
  for testcase in root:
    if testcase.get("skipped", 0) == "1":
      continue

    # get the test classname without middleware info
    # e.g. full.test.ffmpeg-qsv.encode.hevc -> encode.hevc
    classname = '.'.join(testcase.get("classname").split('.')[3:])

    # split the testcase name into test and params
    test, params = testcase.get("name").rstrip(')').split('(')

    if len(filters) and not any(f.matches(classname) or f.matches(test) or f.matches(params) for f in filters):
      continue

    # split the params string into a dict
    params = dict(kv.split('=') for kv in params.split(','))

    # build the fixed params list (without the aggvars)
    fixed = '.'.join('='.join((k,v)) for k,v in params.items() if k not in aggvars)

    # build the aggregate test name
    aggname = ':'.join([classname, test, fixed])

    # find bitrate and psnr details
    bitrate = psnr = None
    for detail in testcase.findall("./detail"):
      if detail.get("name") == "bitrate_actual":
        assert bitrate is None # bitrate_actual detail should only exist once
        bitrate = ast.literal_eval(detail.get("value"))
      elif detail.get("name").endswith("psnr:actual"):
        assert psnr is None # psnr:actual detail should only exist once
        psnr = ast.literal_eval(detail.get("value"))[3]

    # No data found, skip
    if psnr is None or bitrate is None: continue

    # append the bitrate and psnr to the fixed aggregate
    result.setdefault(aggname, list()).append((bitrate, psnr))

  return result

args = parseArgs()
aggvars = args.aggvars.split(',')

refs = Refs(args.ref, args.rebase)

aggA = aggregate(et.parse(sys.argv[1]).getroot(), args.afilters)
aggB = aggregate(et.parse(sys.argv[2]).getroot(), args.bfilters)

tests = 0
errors = 0
failures = 0
skipped = 0

suite = et.Element("testsuite", name = "bdrate", time = "0", timestamp = dt.now().isoformat())

for agg, points in aggA.items():
  tests += 1

  classname, test, fixed = agg.split(':')
  case = et.SubElement(
    suite, "testcase", name = ':'.join([test, fixed]), classname = classname,
    time = "0")

  pointsA = sorted(points)
  pointsB = sorted(aggB.get(agg, list()))

  print()
  print(agg)

  et.SubElement(case, "detail", name = "points-a", value = str(pointsA))
  et.SubElement(case, "detail", name = "points-b", value = str(pointsB))

  if len(pointsB) == 0 or len(pointsA) == 0:
    print("\tDataset missing")
    errors += 1
    et.SubElement(case, "error", type = "error", message = "Dataset missing")
    continue

  if len(pointsA) < 4 or len(pointsB) < 4:
    print("\tDataset too small", len(pointsA), len(pointsB))
    errors += 1
    et.SubElement(case, "error", type = "error", message = "Dataset too small")
    continue

  if args.show_points:
    print("\t", "Points A:", pointsA)
    print("\t", "Points B:", pointsB)

  result = BD_RATE(
    [v[0] for v in pointsA],
    [v[1] for v in pointsA],
    [v[0] for v in pointsB],
    [v[1] for v in pointsB],
  )
  print("\t", "bd-rate:actual", "{:.4f}".format(result))
  et.SubElement(case, "detail", name = "bd-rate:actual", value = str(result))

  def test(ref, val):
    print("\t", "bd-rate:expect", ref if ref is None else "{:.4f}".format(ref))
    et.SubElement(case, "detail", name = "bd-rate:expect", value = str(ref))
    if ref is None or abs(ref - val) > 3:
      et.SubElement(case, "failure", type = "failure", message = "bd-rate change > 3%")
      return 1
    return 0

  failures += refs.check(test, agg, "bd-rate", result)

suite.set("tests", str(tests))
suite.set("errors", str(errors))
suite.set("failures", str(failures))
suite.set("skipped", str(skipped))
tree = et.ElementTree(suite)
filename = os.path.join("bdrate-results.xml")
tree.write(filename)

refs.finalize()
